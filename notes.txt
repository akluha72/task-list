## SECTION 1 What's laravel and why laravel
// how does web application works

## SECTION 2 Laravel setup
// sqlite = A application database that's being stored in the application it self, which means does not required a database connection/embedded in application

## SECTION 3 Discovering Laravel
    // Understanding composer
        --
    // Laravel Directory Structure
        --
    //Laravel Root File
        -- Development and Maintanance 
            -- .env = environment file setup for different 
            -- artisan = php command to be used in cli
            -- editortConfig = IDE environment setup for coding style, to standardize all developer setup.

        -- Version Control
            -- gitIgnore = A listed file that's not supposed to be in version control/or being upload in repository
            -- gitAttribute = setting git behavior 

        -- Composer
            -- composer.json = a declaration of package that will be used in this frameworks, not supposed to be in the respository
            -- composer.lock = a resolve file from composer.json file that is supposed to be uploaded in repository, so that each developer will have the same setup on the application

        -- Test
            -- phpunit.xml to run unit test and features test
        
        -- FrontEnd 
            -- viteConfig.js = configuration vite/ bundler / combining multiple js and css file *should improve front end and assets efficiency.
            -- package.json = the functionality same as the composer.json but for front end package (NPM)
            -- package.lock = it serve a same purpose as the composer.lock but for front end package (NPM)
    
    // How do you configure laravel apps
        -- using environemnt variable the best way
        -- two enviroment [local, staging, production]
        -- Twelve-Factor app 
            * Store config in environment
        -- local will always use .env configuration
        -- Staging & Production will always use System Environment variable

    // Autoloading and PSRs
        -- namespace = matching the folder name it's being define under composer.json
        -- PSR-4 (Php standard recommendation)

    // Using Artisan Command 
        -- artisan is just a way to run artisan command let you manage laravel project, generate file, clear cache and etc 
        -- php artisan serve
        -- php artisan tinker (playing with your app, before you build all the actual features)


## SECTION 4 (Project 1 Task-List)
    //Introduction to the project
        -- list of task, data stored in database
        -- task are paginated
        -- task status (complete or not)
        -- flash message/notification
        -- perform CRUD on task
        -- how to handle from
        -- how to add data into database
        -- validating user input that user has been send
        -- display proper error message to inform the user what should/need to be fix
    
    // Note about the project
        -- all about routing chapter, only have console.php. and web.php files in /route for a reason

    // All about routing
        -- Routing = a process directing user request, take a form of URLs into some specific action that can return a reponse
        -- Get url and run some action 
        -- Dynamic route = a route that will accept a parameter, to do somekind of interaction with our backend of application
        
        // What's HTTP
            -- how to communicate with the server, computer and server only understand http protocol language
            -- GET = fetching, read data a website from the server
            -- POST = create some data in server
            -- PUT = edit some data in server
            -- DELETE =  deleting data in server
    // Route name
        -- use route name instead of using route url
        -- run `php artisan route:list` to see the list of route name
        -- Route::fallback = some generic catch all route that will catch will all url that's not fit based on what route that we have defined. it will never show that 404 page instead you can customize what's the response if the user have enter a wrong url to access your applicatoin.
        -- To use blade template in route return view('{nameOfBladeTemplate})
        -- To pass data into blade use second arguement in array
            -> return view('index',[
                'name' => 'lutfi'
            ]);
            // 'name' is variable
            // 'lutfi' is the value
        
    // Route Common prefix name
        -- Prefix name task
        -- list of element should call 'index'
        -- show one specific should be names 'show'

    //Blade Templating.
        -- Blade Directive
            1. If statement
            2. Loops
            3. Authentications

        -- Use blade template to render dynamic content that can differ dependent to data
        -- to render blade template use view() in route.
        -- to pass data into blade add second arguments on return statement in array
        -- use laravel directive in blade that's start with '@'
        -- to output variable use {{$yourVariables}}
            
            -- Blade directive new knowledge
                => in order to check the variable that's being passed in the blade template, Normally we will use @foreach that is being wrapper in @if directive to check.
                    actually we can use @forelse to the same thing 

    //Template Inheritance 
        -- Some repetitive code in each blade, so we inherit the code instead of DRY code it
        -- using collect() method
            -> convert arrays to a laravel collection object
            -> in php arrays are not object, it's primitve data type. you need to use function to do something in arrays
            -> in java arrays are object. 
    
    //Model and Migrations
        -- php artisan make:model {model name} -m will create model and migration files
        -- model can interact with database table 
            -> create, read, update, delete 
        -- ORM (object relational mapping)
            -> mapping classes to database table
            -> much more method/ construct sql query / instead of writing sql we ORM / using PHP classes
            -> creating and updating

        -- Migration version control of database schema in laravel
            -> modifying your database table using php instead sql (mainpulate database schema)
            -> using PHP object
        
        -- Migration have up() and down()
            -> up()
                --> for going forward / to migrate 
            -> down()
                --> for going back to rollback your migration
        
        -- Use php artisan rollback to revert back to the last migration
            -> but how many migration will it rollback tho? 

    //Model Factory and seeder
        -- generate some fake data to load the database
        1. Factory
            - You can create your own model factories by using artisan
            - to setup/define the fake data that will be created
            - you can also have a variant definition in factory (for example [verified user and unverified user]) so now, seeder will make 12 user with 10 verified user and 2 un-verified user
        2. Seeding
            - will need to define the model and how many of data you wanted to create

        3. Model -> has factories -> have seeder

        -- Php aritsan db:Seed
        -- php artisan migrate:referesh --seed
        -- Task::find(); = one single row but it's primary key
        -- Task::findOrFail($id) = if fail it will show 404 pages it will return null value 
        -- Task::all() = fetch all data
        -- Task::latest()->get() = fetch latest data based on the date
        -- Task::latest()->where('completed', true)->get() = specify based on condition of column
        -- query builder exist all or find need to call get() at the end to execute the query
        -- Use php artisan tinker to test out the ORM \App\Models\Task::select('id', 'title')->where('completed', true)->get();
        -- link for query builder for references = can be found in laravel website

    // Forms and CSRF Protection
        -- what's csrf? 
            -> cross-site request forgery
            -> laravel genearte a unique token, for this form submission it happens in middleware
            -> you need to include crsf for each form, or else you will get the 419 error 
            -> what's session and cookies? how does it work??????
        -- creating a form
            -- input field
                -> name = will be the name of the data submitted by the form
                -> id = binding specific label to the input, example someone click on the label the input will be activated. 
                -
        -- to create a route that's return a view you can simplify the route like this
            -> Route::view('/tasks/create', 'create)
        -- the order/sort of the route does matter. (laravel should fix this / do we need to use route group)
        -- php artisan route:list to view list of route that laravel read. 
        -- Best practise of route sort the route get and post

    // LARAVEL 11 DOESN'T HAVE middleware and kernel need to use configuration in boostrap folder
